package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateUSESMarkdown(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Create sample action uses data
	usesIndex := &ActionUsesIndex{
		Actions: make(map[string]map[string][]WorkflowReference),
	}

	// Add some test data
	usesIndex.Actions["actions/checkout"] = map[string][]WorkflowReference{
		"v4": {
			{RepoName: "repo1", FilePath: ".github/workflows/test.yml"},
			{RepoName: "repo2", FilePath: ".github/workflows/build.yml"},
		},
		"de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2": {
			{RepoName: "repo3", FilePath: ".github/workflows/deploy.yml"},
		},
	}

	usesIndex.Actions["actions/setup-go"] = map[string][]WorkflowReference{
		"v5.0.0": {
			{RepoName: "repo1", FilePath: ".github/workflows/test.yml"},
		},
	}

	// Generate USES.md
	err := generateUSESMarkdown(tempDir, "test-org", usesIndex)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Read the generated file
	usesPath := filepath.Join(tempDir, "USES.md")
	content, err := os.ReadFile(usesPath)
	if err != nil {
		t.Fatalf("Error reading USES.md: %v", err)
	}

	contentStr := string(content)
	t.Logf("Generated USES.md:\n%s", contentStr)

	// Verify the content
	expectedStrings := []string{
		"# GitHub Actions Uses",
		"## actions/checkout",
		"## actions/setup-go",
		"### Version: `v4`",
		"### Version: `de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2`",
		"### Version: `v5.0.0`",
		"**Total Usage**: 3 workflow file(s) across 2 version(s)",
		"**Total Usage**: 1 workflow file(s) across 1 version(s)",
		"<details>",
		"</details>",
		"repo1",
		"repo2",
		"repo3",
	}

	for _, expected := range expectedStrings {
		if !strings.Contains(contentStr, expected) {
			t.Errorf("Expected to find %q in USES.md, but it was not found", expected)
		}
	}

	// Verify that the markdown is properly formatted
	if !strings.HasPrefix(contentStr, "# GitHub Actions Uses") {
		t.Error("USES.md should start with the title")
	}

	if !strings.HasSuffix(strings.TrimSpace(contentStr), "*This file is automatically generated after each data collection run.*") {
		t.Error("USES.md should end with the auto-generated notice")
	}
}

func TestGenerateUSESMarkdown_Empty(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Create empty uses index
	usesIndex := &ActionUsesIndex{
		Actions: make(map[string]map[string][]WorkflowReference),
	}

	// Generate USES.md with empty data
	err := generateUSESMarkdown(tempDir, "test-org", usesIndex)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Verify that no file was created for empty index
	usesPath := filepath.Join(tempDir, "USES.md")
	if _, err := os.Stat(usesPath); err == nil {
		t.Error("USES.md should not be created for empty index")
	}
}

func TestGenerateUSESMarkdown_Nil(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Generate USES.md with nil index
	err := generateUSESMarkdown(tempDir, "test-org", nil)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Verify that no file was created for nil index
	usesPath := filepath.Join(tempDir, "USES.md")
	if _, err := os.Stat(usesPath); err == nil {
		t.Error("USES.md should not be created for nil index")
	}
}
