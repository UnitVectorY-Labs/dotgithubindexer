package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// ------------------------
// Section: Action Uses Parsing Tests
// ------------------------

func TestExtractActionUses(t *testing.T) {
	// Read a sample workflow file
	content, err := os.ReadFile(".github/workflows/build-go.yml")
	if err != nil {
		t.Fatalf("Error reading workflow file: %v", err)
	}

	uses := extractActionUses(string(content), "dotgithubindexer", ".github/workflows/build-go.yml")

	if len(uses) == 0 {
		t.Error("Expected to find action uses, but found none")
	}

	// Check that we found the expected actions
	foundCheckout := false
	foundSetupGo := false
	foundCache := false
	foundCodecov := false

	for _, use := range uses {
		t.Logf("Found action: %s, version: %s", use.Action, use.Version)

		switch use.Action {
		case "actions/checkout":
			foundCheckout = true
			// Check that version includes the comment
			if use.Version == "" {
				t.Error("Expected version for actions/checkout, but got empty string")
			}
		case "actions/setup-go":
			foundSetupGo = true
		case "actions/cache":
			foundCache = true
		case "codecov/codecov-action":
			foundCodecov = true
		}
	}

	if !foundCheckout {
		t.Error("Expected to find actions/checkout")
	}
	if !foundSetupGo {
		t.Error("Expected to find actions/setup-go")
	}
	if !foundCache {
		t.Error("Expected to find actions/cache")
	}
	if !foundCodecov {
		t.Error("Expected to find codecov/codecov-action")
	}
}

func TestParseUsesString(t *testing.T) {
	testCases := []struct {
		name            string
		usesStr         string
		workflowContent string
		expectedAction  string
		expectedVersion string
	}{
		{
			name:    "Simple version",
			usesStr: "actions/checkout@v4",
			workflowContent: `
      - uses: actions/checkout@v4
`,
			expectedAction:  "actions/checkout",
			expectedVersion: "v4",
		},
		{
			name:    "Version with comment",
			usesStr: "actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd",
			workflowContent: `
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
`,
			expectedAction:  "actions/checkout",
			expectedVersion: "de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2",
		},
		{
			name:    "No version",
			usesStr: "actions/checkout",
			workflowContent: `
      - uses: actions/checkout
`,
			expectedAction:  "actions/checkout",
			expectedVersion: "",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			action, version := parseUsesString(tc.usesStr, tc.workflowContent)

			if action != tc.expectedAction {
				t.Errorf("Expected action %q, got %q", tc.expectedAction, action)
			}

			if version != tc.expectedVersion {
				t.Errorf("Expected version %q, got %q", tc.expectedVersion, version)
			}
		})
	}
}

// ------------------------
// Section: USES.md Generation Tests
// ------------------------

func TestGenerateUSESMarkdown(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Create sample action uses data
	usesIndex := &ActionUsesIndex{
		Actions: make(map[string]map[string][]WorkflowReference),
	}

	// Add some test data
	usesIndex.Actions["actions/checkout"] = map[string][]WorkflowReference{
		"v4": {
			{RepoName: "repo1", FilePath: ".github/workflows/test.yml"},
			{RepoName: "repo2", FilePath: ".github/workflows/build.yml"},
		},
		"de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2": {
			{RepoName: "repo3", FilePath: ".github/workflows/deploy.yml"},
		},
	}

	usesIndex.Actions["actions/setup-go"] = map[string][]WorkflowReference{
		"v5.0.0": {
			{RepoName: "repo1", FilePath: ".github/workflows/test.yml"},
		},
	}

	// Generate USES.md
	err := generateUSESMarkdown(tempDir, "test-org", usesIndex)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Read the generated file
	usesPath := filepath.Join(tempDir, "USES.md")
	content, err := os.ReadFile(usesPath)
	if err != nil {
		t.Fatalf("Error reading USES.md: %v", err)
	}

	contentStr := string(content)
	t.Logf("Generated USES.md:\n%s", contentStr)

	// Verify the content
	expectedStrings := []string{
		"# GitHub Actions Uses",
		"## actions/checkout",
		"## actions/setup-go",
		"### Version: `v4`",
		"### Version: `de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2`",
		"### Version: `v5.0.0`",
		"**Total Usage**: 3 workflow file(s) across 2 version(s)",
		"**Total Usage**: 1 workflow file(s) across 1 version(s)",
		"<details>",
		"</details>",
		"repo1",
		"repo2",
		"repo3",
	}

	for _, expected := range expectedStrings {
		if !strings.Contains(contentStr, expected) {
			t.Errorf("Expected to find %q in USES.md, but it was not found", expected)
		}
	}

	// Verify that the markdown is properly formatted
	if !strings.HasPrefix(contentStr, "# GitHub Actions Uses") {
		t.Error("USES.md should start with the title")
	}

	if !strings.HasSuffix(strings.TrimSpace(contentStr), "*This file is automatically generated after each data collection run.*") {
		t.Error("USES.md should end with the auto-generated notice")
	}
}

func TestGenerateUSESMarkdown_Empty(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Create empty uses index
	usesIndex := &ActionUsesIndex{
		Actions: make(map[string]map[string][]WorkflowReference),
	}

	// Generate USES.md with empty data
	err := generateUSESMarkdown(tempDir, "test-org", usesIndex)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Verify that no file was created for empty index
	usesPath := filepath.Join(tempDir, "USES.md")
	if _, err := os.Stat(usesPath); err == nil {
		t.Error("USES.md should not be created for empty index")
	}
}

func TestGenerateUSESMarkdown_Nil(t *testing.T) {
	// Create a temporary directory for testing
	tempDir := t.TempDir()

	// Generate USES.md with nil index
	err := generateUSESMarkdown(tempDir, "test-org", nil)
	if err != nil {
		t.Fatalf("Error generating USES.md: %v", err)
	}

	// Verify that no file was created for nil index
	usesPath := filepath.Join(tempDir, "USES.md")
	if _, err := os.Stat(usesPath); err == nil {
		t.Error("USES.md should not be created for nil index")
	}
}

// ------------------------
// Section: Integration Tests
// ------------------------

func TestIntegrationWorkflowParsing(t *testing.T) {
	// Create a sample workflow content
	workflowContent := `
name: Test Workflow
on: [push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
      
      - name: Setup Go
        uses: actions/setup-go@v5
      
      - name: Cache
        uses: actions/cache@v4.1.0 # latest cache
      
      - name: Custom action
        uses: my-org/my-action@main

  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: actions/upload-artifact@v4
`

	// Test extraction
	uses := extractActionUses(workflowContent, "test-repo", ".github/workflows/test.yml")

	// Verify we found all the uses
	expectedCount := 6
	if len(uses) != expectedCount {
		t.Errorf("Expected to find %d uses, but found %d", expectedCount, len(uses))
	}

	for _, use := range uses {
		t.Logf("Found %s @ %s", use.Action, use.Version)
	}

	// Verify that the comment is captured for actions/checkout with hash
	checkoutWithCommentFound := false
	for _, use := range uses {
		if use.Action == "actions/checkout" && strings.Contains(use.Version, "de0fac2e4500dabe0009e67214ff5f5447ce83dd") && strings.Contains(use.Version, "v6.0.2") {
			checkoutWithCommentFound = true
			break
		}
	}
	if !checkoutWithCommentFound {
		t.Error("Expected to find actions/checkout with version comment (hash # v6.0.2)")
	}
}

func TestRealWorkflowFiles(t *testing.T) {
	// Test with actual workflow files in the repository
	workflowFiles := []string{
		".github/workflows/build-go.yml",
		".github/workflows/codeql-go.yml",
		".github/workflows/release-go-github.yml",
	}

	totalUses := 0
	for _, file := range workflowFiles {
		content, err := os.ReadFile(file)
		if err != nil {
			t.Logf("Skipping %s (not found): %v", file, err)
			continue
		}

		uses := extractActionUses(string(content), "dotgithubindexer", file)
		t.Logf("File %s: found %d uses", file, len(uses))
		for _, use := range uses {
			t.Logf("  - %s @ %s", use.Action, use.Version)
		}
		totalUses += len(uses)
	}

	if totalUses == 0 {
		t.Error("Expected to find at least some action uses across all workflow files")
	}
}
